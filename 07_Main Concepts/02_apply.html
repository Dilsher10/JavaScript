<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 2. apply() – Variadic Functions with Dynamic Context

        // Just like call(), invokes the function immediately.

        // Takes arguments as an array.



        // Example 1:
        function greet(greeting, punctuation) {
            console.log(`${greeting}, ${this.name}${punctuation}`);
        }

        const person = { name: 'Dilsher' };

        greet.apply(person, ['Hello', '!']);



        // Example 2: This is an example of constructor function inheritance using apply().
        function Animal(name) {
            this.name = name;
        }

        function Dog(name, breed) {
            Animal.apply(this, [name]);
            this.breed = breed;
        }
        const dog = new Dog('Buddy', 'Labrador');
        console.log(dog);



        // Example 3: This is class-based inheritance in JavaScript using ES6:
        class Animal {
            constructor(name) {
                this.name = name;
                this.type = type;
            }
        }

        class Dog extends Animal {
            constructor(name, breed) {
                super(name);
                this.breed = breed;
            }
        }

        const classDog = new Dog('Buddy', 'Labrador');
        console.log(classDog);
        



        // Example 4:
        function maxSalary() {
            return Math.max.apply(null, arguments);
        }

        console.log(maxSalary(50000, 75000, 120000));















        // What’s the difference in using spread operator vs. apply() here?

        // apply() lets you call a function with an array of arguments and explicitly set the this context, 
        // while the spread operator (...) simply expands an array into individual arguments without affecting this.



        // Using apply() (sets this explicitly):

        function greetOne(greeting, punctuation) {
            console.log(`${greeting}, ${this.name}${punctuation}`);
        }

        const personOne = { name: 'Dilsher' };

        greetOne.apply(personOne, ['Hello', '!']);

        // Output: Hello, my name is 
        // In this case, apply() sets this to person and passes 'Hello' as an argument.








        // Using spread operator (does NOT set this):

        function greetTwo(greeting) {
            console.log(`${greeting}, my name is ${this.name}`);
        }

        const personTwo = { name: 'Dilsher' };

        greetTwo(...['Hello']);

        // Output: Hello, my name is undefined (or error in strict mode)

        // Here, this is not set to person, so it defaults to undefined (or the global object in non-strict mode), and the result is incorrect.



        // Conclusion:

        // Use apply() when you need to control this.

        // Use spread when you just need to pass arguments, and this doesn’t matter.

    </script>
</body>

</html>