<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            background-color: #333;
        }
    </style>
</head>

<body>
    <!-- In JavaScript, call, apply, and bind are methods of functions that allow you to control the value 
    of this inside the function. They are especially useful when working with objects and method borrowing, 
    or when you need more control over how a function is executed.

    Why We Use call, apply, and bind

    Main Purpose:
    
    To explicitly set the value of this inside a function.
    Use a method from one object for another object.
    JavaScript loses this context in callbacks (like in event handlers or setTimeout), so bind() is useful.


    Common Interview Traps

    "What’s the difference between call and bind?"

    call invokes immediately; bind returns a new function.



    "When would apply be better than call?"

    When passing an unknown number of arguments (like Math.max on arrays).-->



    <script>

        // 1. call() – Method Borrowing

        // Immediately invokes the function.

        // Takes arguments individually.


        // Example 1:

        function greet(greeting, punctuation) {
            console.log(`${greeting}, ${this.name}${punctuation}`);
        }

        const person = { name: 'Dilsher' };

        greet.call(person, 'Hello', '!');



        // Example 2:

        function introduce(language) {
            console.log(`Hi, I'm ${this.name}, and I code in ${language}.`);
        }

        const dev = {
            name: 'Dilsher',
        };

        introduce.call(dev, 'JavaScript');








        // Now refactor this using classes

        // This usually comes up when you've used call() or apply() for inheritance or method borrowing, and 
        // they want to see if you understand ES6 classes, which is the modern, cleaner way to do OOP in JavaScript.



        // This is an example of constructor function inheritance using call().

        function Animal(name) {
            // Assign the 'name' property to the current instance
            this.name = name;
        }

        // Constructor function for "Dog", which inherits from "Animal"
        function Dog(name, breed) {
            // Call the Animal constructor in the context of Dog
            // This copies the 'name' property from Animal to the Dog instance
            Animal.call(this, name); // inherit from Animal

            // Add a new property specific to Dog
            this.breed = breed;
        }

        // Create an instance of Dog
        const dogOne = new Dog('Buddy', 'Labrador');
        // dogOne now has both 'name' and 'breed' properties





        // This is Refactored Using ES6 class Syntax:
        // This is class-based inheritance in JavaScript using ES6:


        // Base class (parent)
        class Animal {
            constructor(name) {
                // Initialize the 'name' property for all animals
                this.name = name;
            }
        }

        // Creates a child class that inherits from Animal.
        class Dog extends Animal {
            constructor(name, breed) {
                // Call the parent class constructor to set the 'name' property
                super(name); // same as Animal.call(this, name)

                // Add a new property specific to Dog
                this.breed = breed;
            }
        }

        // Create an instance of Dog
        const dog = new Dog('Buddy', 'Labrador');
        // dog object now has both 'name' and 'breed' properties






        // Why They Ask:

        // Tests understanding of prototypal inheritance vs classical (class) inheritance.

        // You should know when and why to use super() and extends.

    </script>

</body>

</html>